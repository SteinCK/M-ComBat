
######    M-ComBat   ###########################################################################################
## 
##   Overview:  Script necessary to perform M-ComBat to transform GEP data to
##              a pre-determined, 'gold-standard' subset of samples.
##
##   Requirements:
##    Load 'sva' package
##
##   Input:
##     'dat' = p by n data.frame or matrix , genomic measure matrix 
##                 ( dimensions: probe by sample )
##     'batch' = numeric vector of batch association, length n
##     'center' = numeric value of 'gold-standard' batch
##     'mod' = model matrix of potential covariates
##     'numCovs' = column number of variables in 'mod' to be treated as continuous variables 
##                   (otherwise all covariates treated as factors)
##
#############################################################################################################

#############
# Sample Code

# install sva package from bioconductor
source("http://bioconductor.org/biocLite.R")
biocLite("sva")
library(sva)

# generate sample data (50 samples in set A, 50 samples in set B , for 5 unique genes)
A <- rbind( rnorm( 50 , 10 , 2), rnorm( 50, 11 , 3), rnorm( 50 , 10.5 , 4), rnorm( 50 , 11.5 , 5), rnorm( 50 , 11.5, 2))
B <- rbind( rnorm( 50 , 20 , 2), rnorm( 50, 21 , 3), rnorm( 50 , 21.5 , 4), rnorm( 50 , 20.5 , 5), rnorm( 50 , 20.5, 2))
C <- cbind( A , B )
rownames( C ) <- paste( "Gene", 1:nrow(C))

# define batch and mod inputs for ComBat
batch <- c( rep( 1 , ncol(A)) , rep( 2 , ncol(B) ))
mod <- matrix(rep(1,length(batch)),length(batch),1)


# perform ComBat and M-ComBat transformations on data set
RES1 <- ComBat( C , batch , mod )  
RES2 <- M.COMBAT( C , batch , center=1 , mod )  # perform  M-ComBat centered at batch 1
RES3 <- M.COMBAT( C , batch , center=2 , mod )  # perform  M-ComBat centered at batch 2

# paired scatterplots
pairs(data.frame(t(C)),col=c("blue","red")[batch],xlim=c(0,25),ylim=c(0,25),gap=0)     # Untransformed
pairs(data.frame(t(RES1)),col=c("blue","red")[batch],xlim=c(0,25),ylim=c(0,25),gap=0)  # ComBat
pairs(data.frame(t(RES2)),col=c("blue","red")[batch],xlim=c(0,25),ylim=c(0,25),gap=0)  # M-CoMBat (batch1 center)
pairs(data.frame(t(RES3)),col=c("blue","red")[batch],xlim=c(0,25),ylim=c(0,25),gap=0)  # M-CoMBat (batch2 center)


# the batch parameter can also be a string:
batch = c( rep( 'data from X' , ncol(A)) , rep( 'data from Y' , ncol(B) ))
RES2 <- M.COMBAT( C , batch , center='data from X' , mod )  # perform  M-ComBat centered at batch 1
RES3 <- M.COMBAT( C , batch , center='data from Y' , mod )  # perform  M-ComBat centered at batch 2

pairs(data.frame(t(RES2)),col=c("blue","red"),xlim=c(0,max(RES2)),ylim=c(0,max(RES2)),gap=0)  # M-CoMBat (batch1 center)
pairs(data.frame(t(RES3)),col=c("blue","red"),xlim=c(0,max(RES3)),ylim=c(0,max(RES3)),gap=0)  # M-CoMBat (batch2 center)

####################


############################################################
# Function

M.COMBAT <- function (dat, batch, center, mod, numCovs = NULL){

  mod = cbind(mod, batch)
  check = apply(mod, 2, function(x) all(x == 1))
  mod = as.matrix(mod[, !check])
  colnames(mod)[ncol(mod)] = "Batch"
  if (sum(check) > 0 & !is.null(numCovs)) 
    numCovs = numCovs - 1
  design <- sva:::design.mat(mod, numCov = numCovs)
  batches <- sva:::list.batch(mod)
  n.batch <- length(batches)
  n.batches <- sapply(batches, length)
  n.array <- sum(n.batches)
  NAs = any(is.na(dat))
  if (NAs) {
    cat(c("Found", sum(is.na(dat)), "Missing Data Values\n"), 
        sep = " ")
    stop()
  }
  # until here same as ComBat, except no NA values allowed, and ComBat
  # seems to have some kind of untraceable Beta.NA internal function. 
  cat("Standardizing Data across genes\n")

  
  B.hat <- solve(t(design) %*% design) %*% t(design) %*% t(as.matrix(dat))
  
  # variance of batch of interest
  var.batch <- apply(dat[, batch==center], 1, var)
  
  # batch gene-wise means and standard deviations
  stand.mean =  matrix(NA,nrow(dat),ncol(dat))
  stand.sds = matrix(NA,nrow(dat),ncol(dat))  # initialize stand.mean and stand.sds


  for( i in 1:n.batch){
    stand.mean[,batch==levels(as.factor(batch))[i]] = matrix(B.hat[i,],nrow(dat),n.batches[i])
    stand.sds[,batch==levels(as.factor(batch))[i]] <- matrix(apply(dat[,batch==levels(as.factor(batch))[i]],1,sd),nrow(dat),n.batches[i])
  }

  
  # accounts for covariates here
  if (!is.null(design)) {
    tmp <- design
    tmp[, c(1:n.batch)] <- 0
    stand.mean <- stand.mean + t(tmp %*% B.hat)
  }
  
  
  # standardized data
  s.data <- (dat - stand.mean)/(stand.sds)

  cat("Fitting L/S model and finding priors\n")
  batch.design <- design[, 1:n.batch]
  
  
  gamma.hat <- solve(t(batch.design) %*% batch.design) %*% t(batch.design) %*% t(as.matrix(s.data))
  
  delta.hat <- NULL
  for (i in batches) {
    delta.hat <- rbind(delta.hat, apply(s.data[, i], 1, var,  na.rm = T)) }
  
  gamma.bar <- apply(gamma.hat, 1, mean)
  t2 <- apply(gamma.hat, 1, var)
  a.prior <- apply(delta.hat, 1, sva:::aprior)
  b.prior <- apply(delta.hat, 1, sva:::bprior)
  
  gamma.star <- delta.star <- NULL
  
  cat("Finding parametric adjustments\n")
  for (i in 1:n.batch) {
    
    temp <- sva:::it.sol(s.data[, batches[[i]]], gamma.hat[i,], delta.hat[i, ], gamma.bar[i], t2[i], a.prior[i], b.prior[i])
    
    gamma.star <- rbind(gamma.star, temp[1, ])
    delta.star <- rbind(delta.star, temp[2, ])
  }
  
  cat("Adjusting the Data\n")
  bayesdata <- s.data
  
  k <- (1:n.batch)[- which(levels(as.factor(batch))==center)]
  
  for( t in 1:length(k)){
    
    i <- batches[[k[t]]]
    j <- k[t]
    bayesdata[, i] <- (bayesdata[, i] - t(batch.design[i, ] %*% gamma.star))/(sqrt(delta.star[j, ]) %*% t(rep(1,  n.batches[j])))
    
  }
  bayesdata <- (bayesdata * (sqrt(var.batch) %*% t(rep(1, n.array)))) + matrix( B.hat[which(levels(as.factor(batch))==center),] , nrow(dat) , ncol(dat))
  
  return(bayesdata)
}


##################################################
# functions from sva used

# > sva:::aprior
# function (gamma.hat) 
# {
#     m = mean(gamma.hat)
#     s2 = var(gamma.hat)
#     (2 * s2 + m^2)/s2
# }
# <environment: namespace:sva>
# > sva:::bprior
# function (gamma.hat) 
# {
#     m = mean(gamma.hat)
#     s2 = var(gamma.hat)
#     (m * s2 + m^3)/s2
# }
# <environment: namespace:sva>
# > sva:::it.sol
# function (sdat, g.hat, d.hat, g.bar, t2, a, b, conv = 1e-04) 
# {
#     n <- apply(!is.na(sdat), 1, sum)
#     g.old <- g.hat
#     d.old <- d.hat
#     change <- 1
#     count <- 0
#     while (change > conv) {
#         g.new <- postmean(g.hat, g.bar, n, d.old, t2)
#         sum2 <- apply((sdat - g.new %*% t(rep(1, ncol(sdat))))^2, 
#             1, sum, na.rm = T)
#         d.new <- postvar(sum2, n, a, b)
#         change <- max(abs(g.new - g.old)/g.old, abs(d.new - d.old)/d.old)
#         g.old <- g.new
#         d.old <- d.new
#         count <- count + 1
#     }
#     adjust <- rbind(g.new, d.new)
#     rownames(adjust) <- c("g.star", "d.star")
#     adjust
# }
# <environment: namespace:sva>
############################################